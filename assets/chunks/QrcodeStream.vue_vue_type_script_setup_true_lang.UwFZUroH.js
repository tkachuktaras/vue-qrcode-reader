import{d as X,h as r,y as u,j as Y,A as Z,g as H,o as ee,c as te,k as y,O as ae,a4 as oe,a7 as ne,r as se}from"./framework.FZ7lyoUf.js";import{s as O,b as n,u as ie,c as re,k as ce}from"./camera.R9InlPKq.js";const ue=X({__name:"QrcodeStream",props:{constraints:{type:Object,default(){return{facingMode:"environment"}}},formats:{type:Array,default:()=>["qr_code"]},paused:{type:Boolean,default:!1},torch:{type:Boolean,default:!1},track:{type:Function}},emits:["detect","camera-on","camera-off","error"],setup(N,{emit:j}){const o=N,h=j,_=r(o.constraints),g=r(o.formats);u(()=>o.constraints,(t,e)=>{JSON.stringify(t)!==JSON.stringify(e)&&(_.value=t)},{deep:!0}),u(()=>o.formats,(t,e)=>{JSON.stringify(t)!==JSON.stringify(e)&&(g.value=t)},{deep:!0});const f=r(),v=r(),l=r(),p=r(!1),m=r(!1);Y(()=>{m.value=!0}),Z(()=>{O()});const M=H(()=>({torch:o.torch,constraints:_.value,shouldStream:m.value&&!o.paused}));u(M,async t=>{const e=l.value;n(e!==void 0,"cameraSettings watcher should never be triggered when component is not mounted. Thus video element should always be defined.");const a=f.value;n(a!==void 0,"cameraSettings watcher should never be triggered when component is not mounted. Thus canvas should always be defined.");const d=a.getContext("2d");if(n(d!==null,"if cavnas is defined, canvas 2d context should also be non-null"),t.shouldStream)try{const i=await ie(e,t);m.value?(p.value=!0,h("camera-on",i)):await O()}catch(i){console.log(i),h("error",i)}else a.width=e.videoWidth,a.height=e.videoHeight,d.drawImage(e,0,0,e.videoWidth,e.videoHeight),O(),p.value=!1,h("camera-off")},{deep:!0}),u(g,async t=>{m.value&&await re(t)});const w=H(()=>M.value.shouldStream&&p.value);u(w,t=>{if(t){n(f.value!==void 0,"shouldScan watcher should only be triggered when component is mounted. Thus pause frame canvas is defined"),S(f.value),n(v.value!==void 0,"shouldScan watcher should only be triggered when component is mounted. Thus tracking canvas is defined"),S(v.value);const e=()=>o.track===void 0?500:40;n(l.value!==void 0,"shouldScan watcher should only be triggered when component is mounted. Thus video element is defined"),ce(l.value,{detectHandler:a=>h("detect",a),formats:g.value,locateHandler:J,minDelay:e()})}});const S=t=>{const e=t.getContext("2d");n(e!==null,"canvas 2d context should always be non-null"),e.clearRect(0,0,t.width,t.height)},J=t=>{const e=v.value;n(e!==void 0,"onLocate handler should only be called when component is mounted. Thus tracking canvas is always defined.");const a=l.value;if(n(a!==void 0,"onLocate handler should only be called when component is mounted. Thus video element is always defined."),t.length===0||o.track===void 0)S(e);else{const d=a.offsetWidth,i=a.offsetHeight,b=a.videoWidth,k=a.videoHeight,B=Math.max(d/b,i/k),T=b*B,C=k*B,D=T/b,E=C/k,F=(d-T)/2,z=(i-C)/2,R=({x:c,y:s})=>({x:Math.floor(c*D),y:Math.floor(s*E)}),L=({x:c,y:s})=>({x:Math.floor(c+F),y:Math.floor(s+z)}),I=t.map(c=>{const{boundingBox:s,cornerPoints:Q}=c,{x:U,y:V}=L(R({x:s.x,y:s.y})),{x:$,y:G}=R({x:s.width,y:s.height});return{...c,cornerPoints:Q.map(K=>L(R(K))),boundingBox:DOMRectReadOnly.fromRect({x:U,y:V,width:$,height:G})}});e.width=a.offsetWidth,e.height=a.offsetHeight;const P=e.getContext("2d");o.track(I,P)}},q={width:"100%",height:"100%",position:"relative","z-index":"0"},W={width:"100%",height:"100%",position:"absolute",top:"0",left:"0"},x={width:"100%",height:"100%","object-fit":"cover"},A=H(()=>w.value?x:{...x,visibility:"hidden",position:"absolute"});return(t,e)=>(ee(),te("div",{style:q},[y("video",{ref_key:"videoRef",ref:l,style:ae(A.value),autoplay:"",muted:"",playsinline:""},null,4),oe(y("canvas",{id:"qrcode-stream-pause-frame",ref_key:"pauseFrameRef",ref:f,style:x},null,512),[[ne,!w.value]]),y("canvas",{id:"qrcode-stream-tracking-layer",ref_key:"trackingLayerRef",ref:v,style:W},null,512),y("div",{style:W},[se(t.$slots,"default")])]))}});export{ue as _};
